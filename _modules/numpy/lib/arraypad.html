

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>numpy.lib.arraypad &#8212; Dataset 0.3.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Dataset 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for numpy.lib.arraypad</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The arraypad module contains a group of functions to pad values onto the edges</span>
<span class="sd">of an n-dimensional array.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pad&#39;</span><span class="p">]</span>


<span class="c1">###############################################################################</span>
<span class="c1"># Private utility functions.</span>


<span class="k">def</span> <span class="nf">_arange_ndarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an ndarray of `shape` with increments along specified `axis`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    shape : tuple of ints</span>
<span class="sd">        Shape of desired array. Should be equivalent to `arr.shape` except</span>
<span class="sd">        `shape[axis]` which may have any positive value.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis to increment along.</span>
<span class="sd">    reverse : bool</span>
<span class="sd">        If False, increment in a positive fashion from 1 to `shape[axis]`,</span>
<span class="sd">        inclusive. If True, the bounds are the same but the order reversed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array sized to pad `arr` along `axis`, with linear range from</span>
<span class="sd">        1 to `shape[axis]` along specified `axis`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The range is deliberately 1-indexed for this specific use case. Think of</span>
<span class="sd">    this algorithm as broadcasting `np.arange` to a single `axis` of an</span>
<span class="sd">    arbitrarily shaped ndarray.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">initshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">padarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">padarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">padarr</span> <span class="o">=</span> <span class="n">padarr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">initshape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">padarr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="n">padarr</span> <span class="o">=</span> <span class="n">padarr</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">padarr</span>


<span class="k">def</span> <span class="nf">_round_ifneeded</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rounds arr inplace if destination dtype is integer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        The dtype of the destination array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">arr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepend_const</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend constant `val` along `axis` of `arr`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to prepend.</span>
<span class="sd">    val : scalar</span>
<span class="sd">        Constant value to use. For best results should be of type `arr.dtype`;</span>
<span class="sd">        if not `arr.dtype` will be cast to `arr.dtype`.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` constant `val` prepended along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">padshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">pad_amt</span>
                     <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">arr</span><span class="p">),</span>
                              <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                               <span class="n">arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_append_const</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append constant `val` along `axis` of `arr`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to append.</span>
<span class="sd">    val : scalar</span>
<span class="sd">        Constant value to use. For best results should be of type `arr.dtype`;</span>
<span class="sd">        if not `arr.dtype` will be cast to `arr.dtype`.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` constant `val` appended along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">padshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">pad_amt</span>
                     <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span>
                              <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepend_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend `pad_amt` to `arr` along `axis` by extending edge values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to prepend.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, extended by `pad_amt` edge values appended along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="n">edge_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">0</span>
                       <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">edge_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">edge_arr</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">arr</span><span class="p">),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_append_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append `pad_amt` to `arr` along `axis` by extending edge values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to append.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, extended by `pad_amt` edge values prepended along</span>
<span class="sd">        `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="n">edge_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                       <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">edge_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">edge_arr</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepend_ramp</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend linear ramp along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to prepend.</span>
<span class="sd">    end : scalar</span>
<span class="sd">        Constal value to use. For best results should be of type `arr.dtype`;</span>
<span class="sd">        if not `arr.dtype` will be cast to `arr.dtype`.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values prepended along `axis`. The</span>
<span class="sd">        prepended region ramps linearly from the edge value to `end`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Generate shape for final concatenated array</span>
    <span class="n">padshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">pad_amt</span>
                     <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Generate an n-dimensional array incrementing along `axis`</span>
    <span class="n">ramp_arr</span> <span class="o">=</span> <span class="n">_arange_ndarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">padshape</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                               <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Appropriate slicing to extract n-dimensional edge along `axis`</span>
    <span class="n">edge_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">0</span>
                       <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract edge, reshape to original rank, and extend along `axis`</span>
    <span class="n">edge_pad</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Linear ramp</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">edge_pad</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">)</span>
    <span class="n">ramp_arr</span> <span class="o">=</span> <span class="n">ramp_arr</span> <span class="o">*</span> <span class="n">slope</span>
    <span class="n">ramp_arr</span> <span class="o">+=</span> <span class="n">edge_pad</span>
    <span class="n">_round_ifneeded</span><span class="p">(</span><span class="n">ramp_arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Ramp values will most likely be float, cast them to the same type as arr</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ramp_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_append_ramp</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append linear ramp along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to append.</span>
<span class="sd">    end : scalar</span>
<span class="sd">        Constal value to use. For best results should be of type `arr.dtype`;</span>
<span class="sd">        if not `arr.dtype` will be cast to `arr.dtype`.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values appended along `axis`. The</span>
<span class="sd">        appended region ramps linearly from the edge value to `end`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Generate shape for final concatenated array</span>
    <span class="n">padshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">pad_amt</span>
                     <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Generate an n-dimensional array incrementing along `axis`</span>
    <span class="n">ramp_arr</span> <span class="o">=</span> <span class="n">_arange_ndarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">padshape</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                               <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">edge_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                       <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract edge, reshape to original rank, and extend along `axis`</span>
    <span class="n">edge_pad</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Linear ramp</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">edge_pad</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">)</span>
    <span class="n">ramp_arr</span> <span class="o">=</span> <span class="n">ramp_arr</span> <span class="o">*</span> <span class="n">slope</span>
    <span class="n">ramp_arr</span> <span class="o">+=</span> <span class="n">edge_pad</span>
    <span class="n">_round_ifneeded</span><span class="p">(</span><span class="n">ramp_arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Ramp values will most likely be float, cast them to the same type as arr</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">ramp_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepend_max</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend `pad_amt` maximum values along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to prepend.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate maximum.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values appended along `axis`. The</span>
<span class="sd">        prepended region is the maximum of the first `num` values along</span>
<span class="sd">        `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_prepend_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">max_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate max, reshape to add singleton dimension back</span>
    <span class="n">max_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">max_slice</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `max_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">max_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">arr</span><span class="p">),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_append_max</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad one `axis` of `arr` with the maximum of the last `num` elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to append.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate maximum.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values appended along `axis`. The</span>
<span class="sd">        appended region is the maximum of the final `num` values along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_append_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate max, reshape to add singleton dimension back</span>
    <span class="n">max_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">max_slice</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `max_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">max_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepend_mean</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend `pad_amt` mean values along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to prepend.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate mean.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values prepended along `axis`. The</span>
<span class="sd">        prepended region is the mean of the first `num` values along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_prepend_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">mean_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                       <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate mean, reshape to add singleton dimension back</span>
    <span class="n">mean_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">mean_slice</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
    <span class="n">_round_ifneeded</span><span class="p">(</span><span class="n">mean_chunk</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `mean_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mean_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                           <span class="n">arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_append_mean</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append `pad_amt` mean values along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to append.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate mean.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values appended along `axis`. The</span>
<span class="sd">        appended region is the maximum of the final `num` values along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_append_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mean_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mean_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate mean, reshape to add singleton dimension back</span>
    <span class="n">mean_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">mean_slice</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
    <span class="n">_round_ifneeded</span><span class="p">(</span><span class="n">mean_chunk</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `mean_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mean_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepend_med</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend `pad_amt` median values along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to prepend.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate median.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values prepended along `axis`. The</span>
<span class="sd">        prepended region is the median of the first `num` values along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_prepend_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">med_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate median, reshape to add singleton dimension back</span>
    <span class="n">med_chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">med_slice</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
    <span class="n">_round_ifneeded</span><span class="p">(</span><span class="n">med_chunk</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `med_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span><span class="n">med_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_append_med</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append `pad_amt` median values along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to append.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate median.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values appended along `axis`. The</span>
<span class="sd">        appended region is the median of the final `num` values along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_append_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">med_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">med_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate median, reshape to add singleton dimension back</span>
    <span class="n">med_chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">med_slice</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
    <span class="n">_round_ifneeded</span><span class="p">(</span><span class="n">med_chunk</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `med_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">med_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepend_min</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend `pad_amt` minimum values along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to prepend.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate minimum.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values prepended along `axis`. The</span>
<span class="sd">        prepended region is the minimum of the first `num` values along</span>
<span class="sd">        `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_prepend_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">min_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate min, reshape to add singleton dimension back</span>
    <span class="n">min_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_slice</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `min_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">min_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">arr</span><span class="p">),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_append_min</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append `pad_amt` median values along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : int</span>
<span class="sd">        Amount of padding to append.</span>
<span class="sd">    num : int</span>
<span class="sd">        Depth into `arr` along `axis` to calculate minimum.</span>
<span class="sd">        Range: [1, `arr.shape[axis]`] or None (entire axis)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt` values appended along `axis`. The</span>
<span class="sd">        appended region is the minimum of the final `num` values along `axis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pad_amt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Equivalent to edge padding for single value, so do that instead</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_append_edge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Use entire array if `num` is too large</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Slice a chunk from the edge to calculate stats on</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Extract slice, calculate min, reshape to add singleton dimension back</span>
    <span class="n">min_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_slice</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with `min_chunk`, extended along `axis` by `pad_amt`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">min_chunk</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pad_ref</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad `axis` of `arr` by reflection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : tuple of ints, length 2</span>
<span class="sd">        Padding to (prepend, append) along `axis`.</span>
<span class="sd">    method : str</span>
<span class="sd">        Controls method of reflection; options are &#39;even&#39; or &#39;odd&#39;.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt[0]` values prepended and `pad_amt[1]`</span>
<span class="sd">        values appended along `axis`. Both regions are padded with reflected</span>
<span class="sd">        values from the original array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm does not pad with repetition, i.e. the edges are not</span>
<span class="sd">    repeated in the reflection. For that behavior, use `mode=&#39;symmetric&#39;`.</span>

<span class="sd">    The modes &#39;reflect&#39;, &#39;symmetric&#39;, and &#39;wrap&#39; must be padded with a</span>
<span class="sd">    single function, lest the indexing tricks in non-integer multiples of the</span>
<span class="sd">    original shape would violate repetition in the final iteration.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Implicit booleanness to test for zero (or None) in any scalar type</span>
    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Prepended region</span>

    <span class="c1"># Slice off a reverse indexed chunk from near edge to pad `arr` before</span>
    <span class="n">ref_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="n">ref_chunk1</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">ref_slice</span><span class="p">]</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ref_chunk1</span> <span class="o">=</span> <span class="n">ref_chunk1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1"># Memory/computationally more expensive, only do this if `method=&#39;odd&#39;`</span>
    <span class="k">if</span> <span class="s1">&#39;odd&#39;</span> <span class="ow">in</span> <span class="n">method</span> <span class="ow">and</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">edge_slice1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">0</span>
                            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">edge_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
        <span class="n">ref_chunk1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge_chunk</span> <span class="o">-</span> <span class="n">ref_chunk1</span>
        <span class="k">del</span> <span class="n">edge_chunk</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Appended region</span>

    <span class="c1"># Slice off a reverse indexed chunk from far edge to pad `arr` after</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ref_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">rev_idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">ref_chunk2</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">ref_slice</span><span class="p">][</span><span class="n">rev_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ref_chunk2</span> <span class="o">=</span> <span class="n">ref_chunk2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;odd&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
        <span class="n">edge_slice2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">edge_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
        <span class="n">ref_chunk2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge_chunk</span> <span class="o">-</span> <span class="n">ref_chunk2</span>
        <span class="k">del</span> <span class="n">edge_chunk</span>

    <span class="c1"># Concatenate `arr` with both chunks, extending along `axis`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ref_chunk1</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">ref_chunk2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pad_sym</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad `axis` of `arr` by symmetry.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : tuple of ints, length 2</span>
<span class="sd">        Padding to (prepend, append) along `axis`.</span>
<span class="sd">    method : str</span>
<span class="sd">        Controls method of symmetry; options are &#39;even&#39; or &#39;odd&#39;.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt[0]` values prepended and `pad_amt[1]`</span>
<span class="sd">        values appended along `axis`. Both regions are padded with symmetric</span>
<span class="sd">        values from the original array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm DOES pad with repetition, i.e. the edges are repeated.</span>
<span class="sd">    For padding without repeated edges, use `mode=&#39;reflect&#39;`.</span>

<span class="sd">    The modes &#39;reflect&#39;, &#39;symmetric&#39;, and &#39;wrap&#39; must be padded with a</span>
<span class="sd">    single function, lest the indexing tricks in non-integer multiples of the</span>
<span class="sd">    original shape would violate repetition in the final iteration.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Implicit booleanness to test for zero (or None) in any scalar type</span>
    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Prepended region</span>

    <span class="c1"># Slice off a reverse indexed chunk from near edge to pad `arr` before</span>
    <span class="n">sym_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">rev_idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">sym_chunk1</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">sym_slice</span><span class="p">][</span><span class="n">rev_idx</span><span class="p">]</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sym_chunk1</span> <span class="o">=</span> <span class="n">sym_chunk1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1"># Memory/computationally more expensive, only do this if `method=&#39;odd&#39;`</span>
    <span class="k">if</span> <span class="s1">&#39;odd&#39;</span> <span class="ow">in</span> <span class="n">method</span> <span class="ow">and</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">edge_slice1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">0</span>
                            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">edge_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
        <span class="n">sym_chunk1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge_chunk</span> <span class="o">-</span> <span class="n">sym_chunk1</span>
        <span class="k">del</span> <span class="n">edge_chunk</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Appended region</span>

    <span class="c1"># Slice off a reverse indexed chunk from far edge to pad `arr` after</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">sym_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">sym_chunk2</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">sym_slice</span><span class="p">][</span><span class="n">rev_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sym_chunk2</span> <span class="o">=</span> <span class="n">sym_chunk2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;odd&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
        <span class="n">edge_slice2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">edge_chunk</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">edge_slice2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>
        <span class="n">sym_chunk2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge_chunk</span> <span class="o">-</span> <span class="n">sym_chunk2</span>
        <span class="k">del</span> <span class="n">edge_chunk</span>

    <span class="c1"># Concatenate `arr` with both chunks, extending along `axis`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sym_chunk1</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">sym_chunk2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pad_wrap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad `axis` of `arr` via wrapping.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array of arbitrary shape.</span>
<span class="sd">    pad_amt : tuple of ints, length 2</span>
<span class="sd">        Padding to (prepend, append) along `axis`.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padarr : ndarray</span>
<span class="sd">        Output array, with `pad_amt[0]` values prepended and `pad_amt[1]`</span>
<span class="sd">        values appended along `axis`. Both regions are padded wrapped values</span>
<span class="sd">        from the opposite end of `axis`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method of padding is also known as &#39;tile&#39; or &#39;tiling&#39;.</span>

<span class="sd">    The modes &#39;reflect&#39;, &#39;symmetric&#39;, and &#39;wrap&#39; must be padded with a</span>
<span class="sd">    single function, lest the indexing tricks in non-integer multiples of the</span>
<span class="sd">    original shape would violate repetition in the final iteration.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Implicit booleanness to test for zero (or None) in any scalar type</span>
    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Prepended region</span>

    <span class="c1"># Slice off a reverse indexed chunk from near edge to pad `arr` before</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">wrap_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                       <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">wrap_chunk1</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">wrap_slice</span><span class="p">]</span>

    <span class="c1"># Shape to restore singleton dimension after slicing</span>
    <span class="n">pad_singleton</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">wrap_chunk1</span> <span class="o">=</span> <span class="n">wrap_chunk1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Appended region</span>

    <span class="c1"># Slice off a reverse indexed chunk from far edge to pad `arr` after</span>
    <span class="n">wrap_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                       <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">wrap_chunk2</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">wrap_slice</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">pad_amt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">wrap_chunk2</span> <span class="o">=</span> <span class="n">wrap_chunk2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pad_singleton</span><span class="p">)</span>

    <span class="c1"># Concatenate `arr` with both chunks, extending along `axis`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">wrap_chunk1</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">wrap_chunk2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_normalize_shape</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">cast_to_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function which does some checks and normalizes the possibly</span>
<span class="sd">    much simpler representations of &#39;pad_width&#39;, &#39;stat_length&#39;,</span>
<span class="sd">    &#39;constant_values&#39;, &#39;end_values&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    narray : ndarray</span>
<span class="sd">        Input ndarray</span>
<span class="sd">    shape : {sequence, array_like, float, int}, optional</span>
<span class="sd">        The width of padding (pad_width), the number of elements on the</span>
<span class="sd">        edge of the narray used for statistics (stat_length), the constant</span>
<span class="sd">        value(s) to use when filling padded regions (constant_values), or the</span>
<span class="sd">        endpoint target(s) for linear ramps (end_values).</span>
<span class="sd">        ((before_1, after_1), ... (before_N, after_N)) unique number of</span>
<span class="sd">        elements for each axis where `N` is rank of `narray`.</span>
<span class="sd">        ((before, after),) yields same before and after constants for each</span>
<span class="sd">        axis.</span>
<span class="sd">        (constant,) or val is a shortcut for before = after = constant for</span>
<span class="sd">        all axes.</span>
<span class="sd">    cast_to_int : bool, optional</span>
<span class="sd">        Controls if values in ``shape`` will be rounded and cast to int</span>
<span class="sd">        before being returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    normalized_shape : tuple of tuples</span>
<span class="sd">        val                               =&gt; ((val, val), (val, val), ...)</span>
<span class="sd">        [[val1, val2], [val3, val4], ...] =&gt; ((val1, val2), (val3, val4), ...)</span>
<span class="sd">        ((val1, val2), (val3, val4), ...) =&gt; no change</span>
<span class="sd">        [[val1, val2], ]                  =&gt; ((val1, val2), (val1, val2), ...)</span>
<span class="sd">        ((val1, val2), )                  =&gt; ((val1, val2), (val1, val2), ...)</span>
<span class="sd">        [[val ,     ], ]                  =&gt; ((val, val), (val, val), ...)</span>
<span class="sd">        ((val ,     ), )                  =&gt; ((val, val), (val, val), ...)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndims</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ndim</span>

    <span class="c1"># Shortcut shape=None</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="n">ndims</span>

    <span class="c1"># Convert any input `info` to a NumPy array</span>
    <span class="n">shape_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">shape_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">shape_arr</span><span class="p">,</span> <span class="p">(</span><span class="n">ndims</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;Unable to create correctly shaped tuple from </span><span class="si">%s</span><span class="s2">&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="p">(</span><span class="n">shape</span><span class="p">,))</span>

    <span class="c1"># Cast if necessary</span>
    <span class="k">if</span> <span class="n">cast_to_int</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">shape_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">shape_arr</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Convert list of lists to tuple of tuples</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">shape_arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_validate_lengths</span><span class="p">(</span><span class="n">narray</span><span class="p">,</span> <span class="n">number_elements</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function which does some checks and reformats pad_width and</span>
<span class="sd">    stat_length using _normalize_shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    narray : ndarray</span>
<span class="sd">        Input ndarray</span>
<span class="sd">    number_elements : {sequence, int}, optional</span>
<span class="sd">        The width of padding (pad_width) or the number of elements on the edge</span>
<span class="sd">        of the narray used for statistics (stat_length).</span>
<span class="sd">        ((before_1, after_1), ... (before_N, after_N)) unique number of</span>
<span class="sd">        elements for each axis.</span>
<span class="sd">        ((before, after),) yields same before and after constants for each</span>
<span class="sd">        axis.</span>
<span class="sd">        (constant,) or int is a shortcut for before = after = constant for all</span>
<span class="sd">        axes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _validate_lengths : tuple of tuples</span>
<span class="sd">        int                               =&gt; ((int, int), (int, int), ...)</span>
<span class="sd">        [[int1, int2], [int3, int4], ...] =&gt; ((int1, int2), (int3, int4), ...)</span>
<span class="sd">        ((int1, int2), (int3, int4), ...) =&gt; no change</span>
<span class="sd">        [[int1, int2], ]                  =&gt; ((int1, int2), (int1, int2), ...)</span>
<span class="sd">        ((int1, int2), )                  =&gt; ((int1, int2), (int1, int2), ...)</span>
<span class="sd">        [[int ,     ], ]                  =&gt; ((int, int), (int, int), ...)</span>
<span class="sd">        ((int ,     ), )                  =&gt; ((int, int), (int, int), ...)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normshp</span> <span class="o">=</span> <span class="n">_normalize_shape</span><span class="p">(</span><span class="n">narray</span><span class="p">,</span> <span class="n">number_elements</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">normshp</span><span class="p">:</span>
        <span class="n">chk</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">chk</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">chk</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">chk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">chk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> cannot contain negative values.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="p">(</span><span class="n">number_elements</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">normshp</span>


<span class="c1">###############################################################################</span>
<span class="c1"># Public functions</span>


<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pads an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array_like of rank N</span>
<span class="sd">        Input array</span>
<span class="sd">    pad_width : {sequence, array_like, int}</span>
<span class="sd">        Number of values padded to the edges of each axis.</span>
<span class="sd">        ((before_1, after_1), ... (before_N, after_N)) unique pad widths</span>
<span class="sd">        for each axis.</span>
<span class="sd">        ((before, after),) yields same before and after pad for each axis.</span>
<span class="sd">        (pad,) or int is a shortcut for before = after = pad width for all</span>
<span class="sd">        axes.</span>
<span class="sd">    mode : str or function</span>
<span class="sd">        One of the following string values or a user supplied function.</span>

<span class="sd">        &#39;constant&#39;</span>
<span class="sd">            Pads with a constant value.</span>
<span class="sd">        &#39;edge&#39;</span>
<span class="sd">            Pads with the edge values of array.</span>
<span class="sd">        &#39;linear_ramp&#39;</span>
<span class="sd">            Pads with the linear ramp between end_value and the</span>
<span class="sd">            array edge value.</span>
<span class="sd">        &#39;maximum&#39;</span>
<span class="sd">            Pads with the maximum value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &#39;mean&#39;</span>
<span class="sd">            Pads with the mean value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &#39;median&#39;</span>
<span class="sd">            Pads with the median value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &#39;minimum&#39;</span>
<span class="sd">            Pads with the minimum value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &#39;reflect&#39;</span>
<span class="sd">            Pads with the reflection of the vector mirrored on</span>
<span class="sd">            the first and last values of the vector along each</span>
<span class="sd">            axis.</span>
<span class="sd">        &#39;symmetric&#39;</span>
<span class="sd">            Pads with the reflection of the vector mirrored</span>
<span class="sd">            along the edge of the array.</span>
<span class="sd">        &#39;wrap&#39;</span>
<span class="sd">            Pads with the wrap of the vector along the axis.</span>
<span class="sd">            The first values are used to pad the end and the</span>
<span class="sd">            end values are used to pad the beginning.</span>
<span class="sd">        &lt;function&gt;</span>
<span class="sd">            Padding function, see Notes.</span>
<span class="sd">    stat_length : sequence or int, optional</span>
<span class="sd">        Used in &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, and &#39;minimum&#39;.  Number of</span>
<span class="sd">        values at edge of each axis used to calculate the statistic value.</span>

<span class="sd">        ((before_1, after_1), ... (before_N, after_N)) unique statistic</span>
<span class="sd">        lengths for each axis.</span>

<span class="sd">        ((before, after),) yields same before and after statistic lengths</span>
<span class="sd">        for each axis.</span>

<span class="sd">        (stat_length,) or int is a shortcut for before = after = statistic</span>
<span class="sd">        length for all axes.</span>

<span class="sd">        Default is ``None``, to use the entire axis.</span>
<span class="sd">    constant_values : sequence or int, optional</span>
<span class="sd">        Used in &#39;constant&#39;.  The values to set the padded values for each</span>
<span class="sd">        axis.</span>

<span class="sd">        ((before_1, after_1), ... (before_N, after_N)) unique pad constants</span>
<span class="sd">        for each axis.</span>

<span class="sd">        ((before, after),) yields same before and after constants for each</span>
<span class="sd">        axis.</span>

<span class="sd">        (constant,) or int is a shortcut for before = after = constant for</span>
<span class="sd">        all axes.</span>

<span class="sd">        Default is 0.</span>
<span class="sd">    end_values : sequence or int, optional</span>
<span class="sd">        Used in &#39;linear_ramp&#39;.  The values used for the ending value of the</span>
<span class="sd">        linear_ramp and that will form the edge of the padded array.</span>

<span class="sd">        ((before_1, after_1), ... (before_N, after_N)) unique end values</span>
<span class="sd">        for each axis.</span>

<span class="sd">        ((before, after),) yields same before and after end values for each</span>
<span class="sd">        axis.</span>

<span class="sd">        (constant,) or int is a shortcut for before = after = end value for</span>
<span class="sd">        all axes.</span>

<span class="sd">        Default is 0.</span>
<span class="sd">    reflect_type : {&#39;even&#39;, &#39;odd&#39;}, optional</span>
<span class="sd">        Used in &#39;reflect&#39;, and &#39;symmetric&#39;.  The &#39;even&#39; style is the</span>
<span class="sd">        default with an unaltered reflection around the edge value.  For</span>
<span class="sd">        the &#39;odd&#39; style, the extented part of the array is created by</span>
<span class="sd">        subtracting the reflected values from two times the edge value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pad : ndarray</span>
<span class="sd">        Padded array of rank equal to `array` with shape increased</span>
<span class="sd">        according to `pad_width`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.7.0</span>

<span class="sd">    For an array with rank greater than 1, some of the padding of later</span>
<span class="sd">    axes is calculated from padding of previous axes.  This is easiest to</span>
<span class="sd">    think about with a rank 2 array where the corners of the padded array</span>
<span class="sd">    are calculated by using padded values from the first axis.</span>

<span class="sd">    The padding function, if used, should return a rank 1 array equal in</span>
<span class="sd">    length to the vector argument with padded values replaced. It has the</span>
<span class="sd">    following signature::</span>

<span class="sd">        padding_func(vector, iaxis_pad_width, iaxis, **kwargs)</span>

<span class="sd">    where</span>

<span class="sd">        vector : ndarray</span>
<span class="sd">            A rank 1 array already padded with zeros.  Padded values are</span>
<span class="sd">            vector[:pad_tuple[0]] and vector[-pad_tuple[1]:].</span>
<span class="sd">        iaxis_pad_width : tuple</span>
<span class="sd">            A 2-tuple of ints, iaxis_pad_width[0] represents the number of</span>
<span class="sd">            values padded at the beginning of vector where</span>
<span class="sd">            iaxis_pad_width[1] represents the number of values padded at</span>
<span class="sd">            the end of vector.</span>
<span class="sd">        iaxis : int</span>
<span class="sd">            The axis currently being calculated.</span>
<span class="sd">        kwargs : misc</span>
<span class="sd">            Any keyword arguments the function requires.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3, 4, 5]</span>
<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2,3), &#39;constant&#39;, constant_values=(4, 6))</span>
<span class="sd">    array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2, 3), &#39;edge&#39;)</span>
<span class="sd">    array([1, 1, 1, 2, 3, 4, 5, 5, 5, 5])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2, 3), &#39;linear_ramp&#39;, end_values=(5, -4))</span>
<span class="sd">    array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2,), &#39;maximum&#39;)</span>
<span class="sd">    array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2,), &#39;mean&#39;)</span>
<span class="sd">    array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2,), &#39;median&#39;)</span>
<span class="sd">    array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; a = [[1, 2], [3, 4]]</span>
<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, ((3, 2), (2, 3)), &#39;minimum&#39;)</span>
<span class="sd">    array([[1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [3, 3, 3, 4, 3, 3, 3],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1]])</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3, 4, 5]</span>
<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2, 3), &#39;reflect&#39;)</span>
<span class="sd">    array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2, 3), &#39;reflect&#39;, reflect_type=&#39;odd&#39;)</span>
<span class="sd">    array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2, 3), &#39;symmetric&#39;)</span>
<span class="sd">    array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2, 3), &#39;symmetric&#39;, reflect_type=&#39;odd&#39;)</span>
<span class="sd">    array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, (2, 3), &#39;wrap&#39;)</span>
<span class="sd">    array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span>

<span class="sd">    &gt;&gt;&gt; def padwithtens(vector, pad_width, iaxis, kwargs):</span>
<span class="sd">    ...     vector[:pad_width[0]] = 10</span>
<span class="sd">    ...     vector[-pad_width[1]:] = 10</span>
<span class="sd">    ...     return vector</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; a = a.reshape((2, 3))</span>

<span class="sd">    &gt;&gt;&gt; np.lib.pad(a, 2, padwithtens)</span>
<span class="sd">    array([[10, 10, 10, 10, 10, 10, 10],</span>
<span class="sd">           [10, 10, 10, 10, 10, 10, 10],</span>
<span class="sd">           [10, 10,  0,  1,  2, 10, 10],</span>
<span class="sd">           [10, 10,  3,  4,  5, 10, 10],</span>
<span class="sd">           [10, 10, 10, 10, 10, 10, 10],</span>
<span class="sd">           [10, 10, 10, 10, 10, 10, 10]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`pad_width` must be of integral type.&#39;</span><span class="p">)</span>

    <span class="n">narray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_validate_lengths</span><span class="p">(</span><span class="n">narray</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

    <span class="n">allowedkwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;constant&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;constant_values&#39;</span><span class="p">],</span>
        <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;linear_ramp&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;end_values&#39;</span><span class="p">],</span>
        <span class="s1">&#39;maximum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
        <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
        <span class="s1">&#39;minimum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
        <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
        <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
        <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

    <span class="n">kwdefaults</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;stat_length&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;constant_values&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;end_values&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;reflect_type&#39;</span><span class="p">:</span> <span class="s1">&#39;even&#39;</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">basestring</span><span class="p">):</span>
        <span class="c1"># Make sure have allowed kwargs appropriate for mode</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowedkwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> keyword not in allowed keywords </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">allowedkwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">]))</span>

        <span class="c1"># Set kwarg defaults</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">allowedkwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">]:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="n">kwdefaults</span><span class="p">[</span><span class="n">kw</span><span class="p">])</span>

        <span class="c1"># Need to only normalize particular keywords.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;stat_length&#39;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_validate_lengths</span><span class="p">(</span><span class="n">narray</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;end_values&#39;</span><span class="p">,</span> <span class="s1">&#39;constant_values&#39;</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_normalize_shape</span><span class="p">(</span><span class="n">narray</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                             <span class="n">cast_to_int</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Drop back to old, slower np.apply_along_axis mode for user-supplied</span>
        <span class="c1"># vector function</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Create a new padded array</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">narray</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">total_dim_increase</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rank</span><span class="p">]</span>
        <span class="n">offset_slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">narray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rank</span><span class="p">]</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">narray</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">total_dim_increase</span>
        <span class="n">newmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">narray</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Insert the original array into the padded array</span>
        <span class="n">newmat</span><span class="p">[</span><span class="n">offset_slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">narray</span>

        <span class="c1"># This is the core of pad ...</span>
        <span class="k">for</span> <span class="n">iaxis</span> <span class="ow">in</span> <span class="n">rank</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">function</span><span class="p">,</span>
                                <span class="n">iaxis</span><span class="p">,</span>
                                <span class="n">newmat</span><span class="p">,</span>
                                <span class="n">pad_width</span><span class="p">[</span><span class="n">iaxis</span><span class="p">],</span>
                                <span class="n">iaxis</span><span class="p">,</span>
                                <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newmat</span>

    <span class="c1"># If we get here, use new padding method</span>
    <span class="n">newmat</span> <span class="o">=</span> <span class="n">narray</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># API preserved, but completely new algorithm which pads by building the</span>
    <span class="c1"># entire block to pad before/after `arr` with in one step, for each axis.</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="n">before_val</span><span class="p">,</span> <span class="n">after_val</span><span class="p">))</span> \
                <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;constant_values&#39;</span><span class="p">])):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_const</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">before_val</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_const</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">after_val</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pad_width</span><span class="p">):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_edge</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_edge</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;linear_ramp&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="n">before_val</span><span class="p">,</span> <span class="n">after_val</span><span class="p">))</span> \
                <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;end_values&#39;</span><span class="p">])):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_ramp</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">before_val</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_ramp</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">after_val</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;maximum&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="n">chunk_before</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">))</span> \
                <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">])):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_max</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">chunk_before</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_max</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="n">chunk_before</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">))</span> \
                <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">])):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_mean</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">chunk_before</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_mean</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="n">chunk_before</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">))</span> \
                <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">])):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_med</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">chunk_before</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_med</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;minimum&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="n">chunk_before</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">))</span> \
                <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">])):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_min</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">chunk_before</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_min</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">chunk_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;reflect&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pad_width</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">narray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Axes with non-zero padding cannot be empty.</span>
                <span class="k">if</span> <span class="n">pad_before</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pad_after</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There aren&#39;t any elements to reflect&quot;</span>
                                     <span class="s2">&quot; in axis </span><span class="si">{}</span><span class="s2"> of `array`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
                <span class="c1"># Skip zero padding on empty axes.</span>
                <span class="k">continue</span>

            <span class="c1"># Recursive padding along any axis where `pad_amt` is too large</span>
            <span class="c1"># for indexing tricks. We can only safely pad the original axis</span>
            <span class="c1"># length, to keep the period of the reflections consistent.</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">pad_before</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">pad_after</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">and</span> <span class="n">newmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Extending singleton dimension for &#39;reflect&#39; is legacy</span>
                <span class="c1"># behavior; it really should raise an error.</span>
                <span class="n">newmat</span> <span class="o">=</span> <span class="n">_prepend_edge</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                <span class="n">newmat</span> <span class="o">=</span> <span class="n">_append_edge</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">]</span>
            <span class="n">safe_pad</span> <span class="o">=</span> <span class="n">newmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="p">((</span><span class="n">pad_before</span> <span class="o">&gt;</span> <span class="n">safe_pad</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pad_after</span> <span class="o">&gt;</span> <span class="n">safe_pad</span><span class="p">)):</span>
                <span class="n">pad_iter_b</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">safe_pad</span><span class="p">,</span>
                                 <span class="n">safe_pad</span> <span class="o">*</span> <span class="p">(</span><span class="n">pad_before</span> <span class="o">//</span> <span class="n">safe_pad</span><span class="p">))</span>
                <span class="n">pad_iter_a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">safe_pad</span><span class="p">,</span> <span class="n">safe_pad</span> <span class="o">*</span> <span class="p">(</span><span class="n">pad_after</span> <span class="o">//</span> <span class="n">safe_pad</span><span class="p">))</span>
                <span class="n">newmat</span> <span class="o">=</span> <span class="n">_pad_ref</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_iter_b</span><span class="p">,</span>
                                           <span class="n">pad_iter_a</span><span class="p">),</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                <span class="n">pad_before</span> <span class="o">-=</span> <span class="n">pad_iter_b</span>
                <span class="n">pad_after</span> <span class="o">-=</span> <span class="n">pad_iter_a</span>
                <span class="n">safe_pad</span> <span class="o">+=</span> <span class="n">pad_iter_b</span> <span class="o">+</span> <span class="n">pad_iter_a</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_pad_ref</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pad_width</span><span class="p">):</span>
            <span class="c1"># Recursive padding along any axis where `pad_amt` is too large</span>
            <span class="c1"># for indexing tricks. We can only safely pad the original axis</span>
            <span class="c1"># length, to keep the period of the reflections consistent.</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">]</span>
            <span class="n">safe_pad</span> <span class="o">=</span> <span class="n">newmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">while</span> <span class="p">((</span><span class="n">pad_before</span> <span class="o">&gt;</span> <span class="n">safe_pad</span><span class="p">)</span> <span class="ow">or</span>
                   <span class="p">(</span><span class="n">pad_after</span> <span class="o">&gt;</span> <span class="n">safe_pad</span><span class="p">)):</span>
                <span class="n">pad_iter_b</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">safe_pad</span><span class="p">,</span>
                                 <span class="n">safe_pad</span> <span class="o">*</span> <span class="p">(</span><span class="n">pad_before</span> <span class="o">//</span> <span class="n">safe_pad</span><span class="p">))</span>
                <span class="n">pad_iter_a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">safe_pad</span><span class="p">,</span> <span class="n">safe_pad</span> <span class="o">*</span> <span class="p">(</span><span class="n">pad_after</span> <span class="o">//</span> <span class="n">safe_pad</span><span class="p">))</span>
                <span class="n">newmat</span> <span class="o">=</span> <span class="n">_pad_sym</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_iter_b</span><span class="p">,</span>
                                           <span class="n">pad_iter_a</span><span class="p">),</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                <span class="n">pad_before</span> <span class="o">-=</span> <span class="n">pad_iter_b</span>
                <span class="n">pad_after</span> <span class="o">-=</span> <span class="n">pad_iter_a</span>
                <span class="n">safe_pad</span> <span class="o">+=</span> <span class="n">pad_iter_b</span> <span class="o">+</span> <span class="n">pad_iter_a</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_pad_sym</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pad_width</span><span class="p">):</span>
            <span class="c1"># Recursive padding along any axis where `pad_amt` is too large</span>
            <span class="c1"># for indexing tricks. We can only safely pad the original axis</span>
            <span class="c1"># length, to keep the period of the reflections consistent.</span>
            <span class="n">safe_pad</span> <span class="o">=</span> <span class="n">newmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">while</span> <span class="p">((</span><span class="n">pad_before</span> <span class="o">&gt;</span> <span class="n">safe_pad</span><span class="p">)</span> <span class="ow">or</span>
                   <span class="p">(</span><span class="n">pad_after</span> <span class="o">&gt;</span> <span class="n">safe_pad</span><span class="p">)):</span>
                <span class="n">pad_iter_b</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">safe_pad</span><span class="p">,</span>
                                 <span class="n">safe_pad</span> <span class="o">*</span> <span class="p">(</span><span class="n">pad_before</span> <span class="o">//</span> <span class="n">safe_pad</span><span class="p">))</span>
                <span class="n">pad_iter_a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">safe_pad</span><span class="p">,</span> <span class="n">safe_pad</span> <span class="o">*</span> <span class="p">(</span><span class="n">pad_after</span> <span class="o">//</span> <span class="n">safe_pad</span><span class="p">))</span>
                <span class="n">newmat</span> <span class="o">=</span> <span class="n">_pad_wrap</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_iter_b</span><span class="p">,</span> <span class="n">pad_iter_a</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>

                <span class="n">pad_before</span> <span class="o">-=</span> <span class="n">pad_iter_b</span>
                <span class="n">pad_after</span> <span class="o">-=</span> <span class="n">pad_iter_a</span>
                <span class="n">safe_pad</span> <span class="o">+=</span> <span class="n">pad_iter_b</span> <span class="o">+</span> <span class="n">pad_iter_a</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">_pad_wrap</span><span class="p">(</span><span class="n">newmat</span><span class="p">,</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newmat</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Dataset 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Analysis Center.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>